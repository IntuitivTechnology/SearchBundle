<?php

namespace IT\SearchBundle\Entity\Repository;

use Doctrine\ORM\QueryBuilder;
use IT\SearchBundle\Entity\SearchIndex;

/**
 * SearchIndexRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class SearchIndexRepository extends \Doctrine\ORM\EntityRepository
{

    /**
     * Returns a QueryBuilder corresponding to the first basic search with the option "IN NATURAL LANGUAGE MODE".
     *
     * @param       $terms
     * @param array $entityClassnames
     *
     * @return QueryBuilder
     */
    public function searchQB($terms, array $entityClassnames = array(), $minScore = '0.8', $useResultCache = false)
    {

        $terms = strip_tags(strtolower($terms));

        $qb = $this->createQueryBuilder('si')
            ->select('si, MATCH_AGAINST(si.content, :textFilter \'IN NATURAL LANGUAGE MODE\') as score')
            ->where("MATCH_AGAINST(si.content, :textFilter 'IN NATURAL LANGUAGE MODE') >= " . $minScore)
            ->setParameter('textFilter', $terms)
            ->addOrderBy('score', 'DESC');

        $this->addEntityClassnamesFilter($qb, $entityClassnames);

        if ($useResultCache) {
            return $qb->getQuery()->useResultCache(true, 3600, SearchIndex::CACHE_INDEX);
        } else {
            return $qb;
        }
    }

    /**
     * Returns a QueryBuilder corresponding to the extended search with the option "IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION".
     *
     * @param       $terms
     * @param array $entityClassnames
     *
     * @return QueryBuilder
     */
    public function searchExpandedQB($terms, array $entityClassnames = array(), $minScore = '0.8', $useResultCache = false)
    {

        $terms = strip_tags(strtolower($terms));

        $qb = $this->createQueryBuilder('si')
            ->select('si, MATCH_AGAINST(si.content, :textFilter \'IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION\') as score')
            ->where("MATCH_AGAINST(si.content, :textFilter 'IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION') >= " . $minScore)
            ->setParameter('textFilter', $terms)
            ->addOrderBy('score', 'DESC');

        $this->addEntityClassnamesFilter($qb, $entityClassnames);

        if ($useResultCache) {
            return $qb->getQuery()->useResultCache(true, 3600, SearchIndex::CACHE_INDEX);
        } else {
            return $qb;
        }
    }

    /**
     * Returns a QueryBuilder corresponding to the simple LIKE search
     *
     * @param       $terms
     * @param array $entityClassnames
     *
     * @return QueryBuilder
     */
    public function searchLikeQB($terms, array $entityClassnames = array(), $useResultCache = false)
    {

        $terms = strip_tags(strtolower($terms));

        $qb = $this->createQueryBuilder('si')
            ->select('si')
            ->where("si.content like :textFilter")
            ->setParameter('textFilter', '%' . $terms . '%')
        ;

        $this->addEntityClassnamesFilter($qb, $entityClassnames);

        if ($useResultCache) {
            return $qb->getQuery()->useResultCache(true, 3600, SearchIndex::CACHE_INDEX);
        } else {
            return $qb;
        }
    }

    /**
     * Adds a WHERE on the classname to filter the results with a set of classnames
     *
     * @param QueryBuilder $qb
     * @param array        $entityClassnames
     */
    protected function addEntityClassnamesFilter(QueryBuilder $qb, array $entityClassnames = array())
    {
        if (is_array($entityClassnames) && count($entityClassnames) > 0) {
            $qb
                ->andWhere('si.classname IN (:classnames)')
                ->setParameter('classnames', $entityClassnames);
        }
    }

}